{"posts":[{"title":"图数据库及相关算法在解决客户投诉代理识别中的应用","text":"问题背景在处理投诉过程中公司监测到投诉人存在非法代理虚假投诉现象，疑似非法代理人/机构以所谓征信洗白、伪造证明材料、向监管机构缠访、闹访等赚取不当利益的代理行为，协助客户与公司协商，要求处理合同相关问题（包括但不限于删除逾期征信，减免息费），非法代理行为不仅危害公司利益且易引发更多的恶意投诉。针对此问题本项目通过业务部门采集的客户投诉电话号码以及投诉人提供的接受资料的电子邮箱等信息来判断客户是否为代理人员。我们采用图数据的形式整理展现数据，让本来略显杂乱的数据直观的展现出来。非技术人员也能通过图的展示轻易找到并准确判断哪些客户是代理人员。并且通过图嵌入算法将图中的节点以向量形式表达，供给机器学习模型作为特征使用，实现了较为准确的分类。通过分类鉴别代理人员，将结果反馈给相关业务人员。可以提高服务的效率并提升服务质量。 解决方案整合原始数据，将整理后的数据按照图数据库的要求进行数据转换，将处理好的数据通过专用的图数据软件工具（Neo4j）做直观展示。同时对图数据的节点做特征提取（Embedding），最后可以将提取好的特征做分类算法，从而判断是否为代理人。如下图所示： 图数据库选型鉴于本项目的数据存放，特征提取以及基本关系展示都利用到了图数据库，选择一个合适的技术方案是否重要。如下是目前流行的几个具备开源版本的图数据库： 考虑到初始化的研发投入，社区支持，工具丰富度等因素，以及对于未来大规模企业化应用的支持，我们选择了Neo4j。 数据处理和格式转换图数据库中有不同类型的节点，如邮件，电话，客户，节点之间存在关联，表示某一客户通过某一电话来电投诉，或留下某一邮件地址作为后续联络方式等：对于业务人员记录的邮箱信息，会有部分信息遗漏造成数据缺失的问题，我们通过从邮件的原始信息中，用正则匹配的方式来提取用户的邮箱信息，来对邮箱数据进行补充。 模型训练我们采取两步走的方式，首先根据图结构训练图中每个节点的embedding向量，然后将embedding向量结果提供给后续机器学习分类模型作为特征使用。本着从易到难的路径，我们对不同的图嵌入（Embedding）算法和分类算法分别进行了尝试： 图嵌入算法 vs 统计特征基于图嵌入算法生成的embedding向量可以计算每一对节点的相似度，相似度越大则两个节点之间越有可能产生连接。对于我们的异构图模型，目标是要进行用户节点的分类，所以只需比较每一对用户节点的相似度，两用户节点间跳数越少，相似度越大。因此我们利用embedding计算出的余弦相似度作为用户节点对的score，选择score阈值0.8。针对某一个用户，记录该用户所在的连通图中关联的所有用户数total_u，并计算出与该用户相似度score&gt;=0.8且在连通图的所有用户数top_u。选择多组用户的准确率avg(sum(top_u/total_u))作为评估指标，对embedding进行评估。 我们首先选择适用于异构图的经典图嵌入算法metapath2vec，并分别使用两个图算法框架SellarGraph和Pytorch Geometric来实现该算法。算法首先要在图中选取由节点类型构成的组合路径，基于meta path在图上进行随机游走。但是基于PyG实现的metapath2vec目前只支持单一meta path，训练结果embedding结果不佳。基于StellarGraph实现的metapath2vec可以支持multi-meta path，但是训练的loss值过高，无法使用。后续又尝试了阿里的GATNE异构图Embedding算法。GATNE算法包括两种：GATNE-T和GATNE-I。 GATNE(General Attributed Multiplex HeTerogeneous Network Embedding)算法模型获取了丰富的属性信息并且利用了不同节点的多重拓扑结构。GATNE的主要特点如下：① 定义了属性复用异构图嵌入问题；② GATNE支持直推式学习（GATNE-T）和归纳式学习（GATNE-I）。并且理论证明了本文的直推式模型比现有的模型更一般化；③ 有很好的可扩展性，可处理上亿级别的节点和十亿级别的边。 GATNE-T的embedding再经过数轮的调优后，结果可用。以下是GATNE-T的调优结果： 但是GATNE-T不能单独为新加入的节点生成Embedding，也就是不能使用训练集训练好的参数，用户生成（训练时不可见的）测试集的节点嵌入表示，必须重新训练。由于计算资源的限制（没有GPU），每次重新训练需要5天之久，完全不能满足业务需求。为此，我们还尝试了neo4j提供的HashGNN，训练时间可以满足，但是模型效果不好。在模型效果和时效性上，GATNE-T和HashGNN让我们陷入了两难的境地。只能另寻出路，尝试传统的统计聚合类型的特征+图特征。这三种特征提取方案的比较如下： 最终上线模型没有采用Embedding算法来计算用户特征，而是使用了传统的统计聚合类型的特征+图特征来替换了Embedding特征。 分类算法本项目要解决的问题目标是判断用户是否为投诉代理，所以可以看成是二分类问题。除了模型使用的测试数据，又使用近2个月新数据作为验证数据，对模型进行了验证。但是模型对于新数据的预测结果不理想，模型泛化能力较弱。考虑是正负样本数据不均衡原因导致，使用SMOTE算法构建新的少数类样本，评测指标有所提升。分类算法特征：得到图嵌入模型生成的n维（我们模型是200维）后，直接用这200维特征作为机器学习分类算法的特征。分类算法的分类标签：一是业务标记的代理，二是有共用电子邮箱（提供接受资料的邮箱）的用户标记为代理。我们选取了四种机器学习算法模型进行了测试：LR, SVM, RF, XGBoost。样本总数量：67520代理样本（标签为1）数量：1735非代理样本（标签为0）数量：65785评估指标：AUC和准确率对比测试结果： XGBoost胜出！ 对于特征提取算法+分类算法所产生的结果，我们使用F1 Score来进行评估，要求不低于0.8才能上线。鉴于使用统计特征+图特征所带来的相对于GATNE-T的减分（F1 Score：0.78），我们又将神经网络引入，结合前述的三类特征提取算法，有了如下比较：可以看出，利用较少的统计特征+图特征进行特征提取，后续使用神经网络进行分类，即满足了计算结果的时效性，也能提供一个比较不错的结果（F1 Score： 0.84）。","link":"/2023/07/11/anti-agent/"},{"title":"前端自动化测试的挑战和应对","text":"前端界面自动化测试是一种通过模拟用户操作来验证前端功能和界面的测试方法。它可以提高测试效率，减少人工干预，提升软件质量。但是，前端界面自动化测试也面临着一些挑战，比如： 前端界面变更频繁，导致测试用例失效或难以维护 前端界面涉及多种元素和交互，导致测试用例复杂或不稳定 前端界面需要适配多种浏览器和设备，导致测试用例覆盖不全或执行缓慢 针对这些挑战，有以下一些建议： 选择合适的自动化测试框架。前端自动化的流派主要分为三类：基于录制回放技术的自动化测试框架，基于对文档对象模型 (DOM）对象进行解析的自动化测试框架，以及基于图像识别的自动化测试框架。每种框架都有其优缺点和适用场景，需要根据项目的特点和需求进行选择。 优先进行单元测试和服务测试。前端项目通常UI变化频繁，一旦发生变化，UI测试用例就无法执行且难以维护，所以UI自动化测试的成本高，收益小；相比UI测试，Service测试更加简单直接且变化不会很频繁；单元测试主要对公共函数、方法进行测试，测试用例复用度高且更能保证代码质量。因此，在进行前端自动化测试时，应该优先考虑单元测试和服务测试，并尽量覆盖所有可能出现的情况。 使用云测平台或容器技术。为了解决前端界面需要适配多种浏览器和设备的问题，可以使用云测平台或容器技术来提供多样化的环境和资源，并实现并行执行、实时监控、远程调试等功能。这样可以节省本地资源、提高执行速度、增强可靠性。 那么如何编写高质量的前端自动化测试用例呢？ 编写高质量的前端自动化用例是一项重要的技能，它可以帮助你更有效地验证前端功能和界面，发现并修复缺陷，提升软件质量。以下是一些编写高质量的前端自动化用例的原则和规范： 针对稳定且重要的业务基础代码编写测试用例，比如通用组件、通用算法和数据模块等，避免频繁变更的UI元素和交互。 遵循测试用例编写的统一格式，包括测试编号、测试标题、测试目标、测试步骤、预期结果、实际结果等，并使用清晰明确的语言描述。 设计合理且完备的测试数据，覆盖正常情况和异常情况，并尽量使用真实或接近真实的数据。 采用模块化和参数化的方式编写测试用例，提高复用性和可维护性，并避免硬编码和冗余代码。 使用断言或检查点来验证预期结果是否与实际结果一致，并在出现错误时及时报告并记录日志。 定期执行回归测试，并根据产品需求或代码变更及时更新或删除无效或过时的测试用例。 自动化测试工具： 前端自动化测试工具有很多种，以下是一些常用的前端自动化测试工具： Karma：一个测试运行平台，可以在多个真实浏览器中运行测试用例，并提供实时反馈。它可以集成多种测试框架（如Jasmine、Mocha等）和断言库（如Chai、Sinon等），并支持代码覆盖率报告和持续集成。 Jest：一个基于Jasmine的JavaScript测试框架，可以对React、Vue等前端框架进行单元测试和快照测试。它内置了断言库、模拟库、代码覆盖率工具等功能，并提供了简洁的API和快速的执行速度。 Selenium：一个用于Web应用程序自动化测试的工具，可以模拟用户在浏览器中的操作，并验证预期结果。它支持多种编程语言（如Java、Python、Ruby等）和浏览器（如Chrome、Firefox、IE等），并提供了WebDriver API和IDE插件。 Cypress：一个全新的前端自动化测试框架，可以对Web应用程序进行端到端的集成测试。它不需要依赖Selenium或其他外部服务，而是直接运行在浏览器中，并提供了丰富的API和图形界面。","link":"/2023/03/16/fe-auto-testing/"},{"title":"Node.js 浅析","text":"什么是 Node.js官方定义 Node.js 是一个开源的，跨平台的 Javascript 运行时环境。 要理解这个定义需要从 Javascript 的前身谈起。在 2009 年 Node.js 出现之前，Javascript 只能运行在浏览器中，作为网页脚本使用。而 Node.js 的出现，使 Javascript 可以象其它编程语言一样运行在计算机上，Node.js 之于 Javascript 可以类比 JRE 之于 Java。所以 Node.js 不是一个编程语言，也不是一个 Javascript 框架，它是一整套 Javascript 的运行时环境（Runtime）。 由于 Node.js 的出现，使 Javascript 彻底摆脱浏览器成为一门独立的编程语言。和其它编程语言 Python, Java, Rube 等一样，除了本身擅长前端开发以外，Javascript 也可以开发后台、GUI程序、CLI命令行工具等等。Javascript 有庞大开发者基础，所以 Node.js 的出现使基于 Javascript 的技术栈直接井喷。 Node.js 的安装使用可以参考：Node.js Tutorial Node.js 的特点Node.js 本身的核心模块包括文件系统I/O、网络（HTTP、TCP、UDP、DNS、TLS/SSL等）、二进制数据流、加密算法、数据流等等。Node.js 模块的 API 形式简单，降低了编程的复杂度。 Node.js 的最大特点在于它基于高性能的 Chrome V8 引擎，提供了一个单线程 NIO (非阻塞队列) 的事件驱动模型。这使它极其高效和轻量级。 如上图所示，Node.js 的核心是一个事件驱动的单线程非阻塞 Event Loop 用来处理所有的请求（由于是单线程，所以不需要锁，避免了多线程带来的复杂性和开销），这样的设计让 Node.js 非常擅于 IO 密集型的应用，能够充分用效的利用硬件资源，从而提供更高的并发性能。 性能对比引用：Node.js vs Springboot: Hello world performance comparison 传统 Spring Boot 和 Node.js 的性能对比。需要说明的是这并不是一个严谨的比较，因为基于 Java 语言也有很多优秀的 NIO 模型框架，比如 Netty、以及基于 Netty 的 spring5-webflux，其提供了恐怖的并发性能。所以这个比较只是一个示例，用于说明 Node.js 在特定场景下的的优势，仅供参考。勿喷。 Node.js 的适用场景迄今为止 Node.js 发展出了一个庞大且完善的生态系统，提供了各种各样的第三方模块和工具，例如 Express、Koa、Nest 以及数不清的 Javascript Library。但传统的语言比如 Java 在生态方面一样非常强大。 从业务角度来讲 Node.js 的最大优点是易上手、开发简单速度快，Javascript 的语言特性可以让开发者以极快的速度响应不断变化的业务场景，前后端可以用同一种语言实现代码复用。另外生态强大就意味着轮子多，文档完善，有什么需求找合适的轮子直接用，提高生产效率。所以 Node.js 在开发轻量级、快速迭代、实时交互等类型的 Web 应用程序方面是有优势的。 从技术角度来讲，轻量、快速、实时的网络应用程序，例如聊天、游戏、社交等领域是 Node.js 的强项。 从资源占用方面来讲，Node.js 通常可以让你用更少的代价去高效的利用资源（CPU、Memory…），以支撑更高的访问量。 相反的，重量级、稳定可靠、安全保密等类型的 Web 应用程序，可能并不适合用 Node.js 来进行开发。但 Node.js 的社区也在不断发展，需要持续关注 Node.js 带来的可能性。","link":"/2023/03/10/nodejs-brief/"},{"title":"关于我们","text":"我们是一群对信息数字化技术有兴趣，有热情的金融领域的从业人员，创建这个网站，是想把在工作，学习之中的实践，想法，感悟做一个的记录，也期待能够做到积累，甚至帮助他人。 这个网站叫“捷径”，但其实“捷” 字仅仅是一个关于我们来自何方的暗示，并非对网站内容的自傲和宣传。恰恰相反，对于技术的演进，数字化的探索，通常没有捷径，不论是系统研发，架构设计，云原生平台，安全技术，每一个领域的落地都往往伴随着失败，试错，妥协，改进，正是在这些略显枯燥，却蕴含挑战的循环中，诞生出服务于企业和客户的数字化解决方案，提高效率，实现价值。而这个网站仅仅是记录我们在企业数字化发展“路径”中的所得，所思，所感，故名为“捷径”，期待在这里能和更多的同行交流，学习，成长。 关于网站内容，主要聚焦技术领域的方方面面，前端，后端，开发，设计，架构，安全，AI，数据，初期有可能略显混乱，但现实中最大的挑战却是能否长久的坚持。也期待未来这里能够成长为一个较高水平的技术博客。 最后，在对应github的空间，也有一些小伙伴的开源作品 https://github.com/fintech-path ，有需要的朋友可以参考，也欢迎大家的参与或提出意见。","link":"/2023/06/30/welcome/"},{"title":"React Hooks","text":"Reactjs是一个用于构建用户界面的JavaScript库，它提供了一种称为Hooks的特性，让你可以在函数组件中使用状态和其他React特性，而不需要写类组件。 Reactjs提供了以下几种HooksuseState useState: 用于在函数组件中添加状态。它返回一个状态变量和一个更新该变量的函数。你可以在组件中多次使用useState来定义多个状态变量。 useEffect useEffect: 用于在函数组件中执行副作用，如数据获取、订阅、定时器等。它接受一个函数作为参数，该函数会在每次渲染后执行。你可以在组件中多次使用useEffect来定义多个副作用。 useContext useContext：用于在函数组件中访问React的上下文。它接受一个上下文对象作为参数，并返回该上下文的当前值。你可以使用useContext来避免通过多层组件传递props。 useReducer useReducer：用于在函数组件中管理复杂的状态逻辑。它接受一个reducer函数和一个初始状态作为参数，并返回一个当前状态和一个分发action的函数。你可以使用useReducer来替代useState，当你的状态逻辑包含多个子值或者依赖于之前的状态时。 useCallback useCallback：用于在函数组件中缓存函数。它接受一个内联函数和一个依赖数组作为参数，并返回该函数的缓存版本。你可以使用useCallback来避免不必要的重新渲染，当你把函数作为props传递给子组件时。 useMemo useMemo：用于在函数组件中缓存计算结果。它接受一个创建值的函数和一个依赖数组作为参数，并返回该值的缓存版本。你可以使用useMemo来避免重复计算，当你的计算结果依赖于一些变化较少的值时。 useRef useRef: 用于在函数组件中创建可变的引用对象。它接受一个初始值作为参数，并返回一个包含当前值属性（.current) 的对象。你可以使用useRef来保存任何可变值，而不会触发重新渲染，例如DOM元素、定时器ID等。 useImperativeHandle useImperativeHandle: 用于在自定义Hook中自定义暴露给父组件的ref对象。它接受一个ref对象和一个创建ref对象当前值属性（.current) 的回调函数作为参数，并将回调函数返回的结果分配给ref对象当前值属性（.current) 。你可以使用useImperativeHandle来控制父组件通过ref访问子组件实例时能够访问到什么内容。 useLayoutEffect useLayoutEffect: 与useEffect类似，但是会在所有DOM更改之后同步执行副作用回调，在浏览器绘制之前执行回调，在大多数情况下应该优先使用useEffect，除非需要从DOM读取布局并同步触发更新，在这种情况下应该使用useLayoutEffect useDebugValue useDebugValue: 可以被自定义Hook开发者使用，在 React DevTools 中显示自定义hook标签。 以下是一些使用Hooks的示例代码useState12345678910111213141516171819202122232425import React, { useState } from &quot;react&quot;;function Counter() { // 定义一个名为count的状态变量，初始值为0 const [count, setCount] = useState(0); // 定义一个函数，用于增加count的值 function increment() { setCount(count + 1); } // 定义一个函数，用于减少count的值 function decrement() { setCount(count - 1); } // 返回一个JSX元素，显示count的值和两个按钮 return ( &lt;div&gt; &lt;p&gt;当前计数：{count}&lt;/p&gt; &lt;button onClick={increment}&gt;+1&lt;/button&gt; &lt;button onClick={decrement}&gt;-1&lt;/button&gt; &lt;/div&gt; );} useEffect12345678910111213141516171819202122import React, { useEffect, useState } from &quot;react&quot;;function Clock() { // 定义一个名为time的状态变量，初始值为当前时间 const [time, setTime] = useState(new Date()); // 使用useEffect定义一个副作用，每隔一秒更新time的值 useEffect(() =&gt; { // 创建一个定时器ID const timerID = setInterval(() =&gt; { setTime(new Date()); }, 1000); // 返回一个清理函数，在组件卸载时取消定时器 return () =&gt; { clearInterval(timerID); }; }, []); // 空数组表示只在组件挂载时执行一次 // 返回一个JSX元素，显示当前时间 return &lt;p&gt;现在是：{time.toLocaleTimeString()}&lt;/p&gt;;} useReducer123456789101112131415161718192021222324252627import React, { useReducer } from &quot;react&quot;;// 定义一个reducer函数，根据action的类型更新statefunction reducer(state, action) { switch (action.type) { case &quot;increment&quot;: return { count: state.count + 1 }; case &quot;decrement&quot;: return { count: state.count - 1 }; default: throw new Error(); }}function Counter() { // 使用useReducer定义一个名为state的状态变量和一个名为dispatch的函数，初始值为{count:0} const [state, dispatch] = useReducer(reducer, { count: 0 }); // 返回一个JSX元素，显示state.count的值和两个按钮 return ( &lt;div&gt; &lt;p&gt;当前计数：{state.count}&lt;/p&gt; &lt;button onClick={() =&gt; dispatch({ type: &quot;increment&quot; })}&gt;+1&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({ type: &quot;decrement&quot; })}&gt;-1&lt;/button&gt; &lt;/div&gt; );} useCallback123456789101112131415161718192021222324import React, { useCallback, useState } from &quot;react&quot;;function Child({ increment }) { // 返回一个JSX元素，显示一个按钮 return &lt;button onClick={increment}&gt;+1&lt;/button&gt;;}function Parent() { // 定义一个名为count的状态变量，初始值为0 const [count, setCount] = useState(0); // 使用useCallback定义一个函数，用于增加count的值，并将count作为依赖项 const increment = useCallback(() =&gt; { setCount((prevCount) =&gt; prevCount + 1); }, [count]); // 返回一个JSX元素，显示count的值和Child组件 return ( &lt;div&gt; &lt;p&gt;当前计数：{count}&lt;/p&gt; &lt;Child increment={increment} /&gt; &lt;/div&gt; );} useContext123456789101112131415161718192021222324252627import React, { useContext } from &quot;react&quot;;// 创建一个名为ThemeContext的上下文对象，并设置默认值为lightconst ThemeContext = React.createContext(&quot;light&quot;);function App() { // 定义一个名为theme的状态变量，初始值为dark const [theme, setTheme] = React.useState(&quot;dark&quot;); // 定义一个函数，用于切换theme的值 function toggleTheme() { setTheme((prevTheme) =&gt; (prevTheme === &quot;dark&quot; ? &quot;light&quot; : &quot;dark&quot;)); } // 返回一个JSX元素，使用ThemeContext.Provider包裹子组件，并传递theme作为value属性 return ( &lt;ThemeContext.Provider value={theme}&gt; &lt;div&gt; &lt;p&gt;当前主题：{theme}&lt;/p&gt; &lt;button onClick={toggleTheme}&gt;切换主题&lt;/button&gt; &lt;Toolbar /&gt; &lt;/div&gt; &lt;/ThemeContext.Provider&gt; );}function Toolbar() {","link":"/2023/03/16/react-hooks/"}],"tags":[{"name":"graphdb","slug":"graphdb","link":"/tags/graphdb/"},{"name":"embedding","slug":"embedding","link":"/tags/embedding/"},{"name":"neural network","slug":"neural-network","link":"/tags/neural-network/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"react.js","slug":"react-js","link":"/tags/react-js/"}],"categories":[{"name":"graphdb","slug":"graphdb","link":"/categories/graphdb/"},{"name":"测试","slug":"测试","link":"/categories/%E6%B5%8B%E8%AF%95/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"machine learning","slug":"graphdb/machine-learning","link":"/categories/graphdb/machine-learning/"}],"pages":[]}